
// These tests can be run with cbUnit: https://github.com/Taitava/cbUnit

Include "CommandLineArguments.cb"

Const CBUNIT_FORCE_VARIABLE_DECLARATION = 1
Const CBUNIT_STOP_AT = "function" // If test_DefineCommandLineArguments() fails, do not call test_ParseCommandLineArguments().

Const valid_argument_definition = "--valid-argument:v+ -a -b+ --long-argument-without-value"
Global valid_argument_definition_quoted : valid_argument_definition_quoted = Chr(34) + valid_argument_definition + Chr(34)


//**
// This function is every time before calling any of the test_*() functions.
//*
Function hook_SetupTest(function_name$)
	If function_name <> "test_DefineCommandLineArguments" Then // No need To do this For test_DefineCommandLineArguments()
		DefineCommandLineArguments(valid_argument_definition) // Actually we should already have a definition like this, but do it just in Case test_DefineCommandLineArguments() was Not called For some reason.
	EndIf
EndFunction

Function test_DefineCommandLineArguments()
	
	// These definitions should _Not_ work:
	assertNot(DefineCommandLineArguments("argument-without-dashes-at-the-beginning"), "DefineCommandLineArguments() should n"+"ot accept arguments that do n"+"ot begin with --")
	assertNot(DefineCommandLineArguments("--valid-argument argument-without-dashes-at-the-beginning"), "DefineCommandLineArguments() should n"+"ot accept arguments that do n"+"ot begin with --")
	assertNot(DefineCommandLineArguments("--"), "DefineCommandLineArguments() should n"+"ot accept arguments that do n"+"ot have a nmae After --")
	assertNot(DefineCommandLineArguments("--valid-argument --"), "DefineCommandLineArguments() should n"+"ot accept arguments that do n"+"ot have a nmae After --")
	
	// These definitions _should_ work:
	If assert(DefineCommandLineArguments(valid_argument_definition), "DefineCommandLineArguments() should understand "+valid_argument_definition_quoted) Then
		assertEquals(CountCommandLineArgumentsDefined, 4, "DefineCommandLineArguments() defined a$ arguments, but it should define b$ arguments fo"+"r "+valid_argument_definition_quoted)
	EndIf
	
EndFunction

Function test_ParseCommandLineArguments()
	
	// These arguments should fail:
	assertNot(ParseCommandLineArguments("--undefined-argument"), "ParseCommandLineArguments() should n"+"ot accept undefined argument names.")
	assertNot(ParseCommandLineArguments("-u"), "ParseCommandLineArguments() should n"+"ot accept undefined argument names.")
	assertNot(ParseCommandLineArguments("-v"), "Argument -v is defined to have a value associated with it. ParseCommandLineArguments() should n"+"ot accept a CommandLine with -v without a value.")
	assertNot(ParseCommandLineArguments("invalid-value"), "ParseCommandLineArguments() should n"+"ot accept nameless arguments because DefineCommandLineArguments() was Not called with a definition String ending with a *")
	assertNot(ParseCommandLineArguments("-v valid-value invalid-value"), "ParseCommandLineArguments() should n"+"ot accept nameless arguments because DefineCommandLineArguments() was Not called with a definition String ending with a *")
	
	// Change so that nameless arguments will be allowed
	CommandLineAcceptNamelessArguments = True
	
	// These arguments should be ok:
	assert(ParseCommandLineArguments("nameless-argument-value"), "ParseCommandLineArguments() should accept nameless arguments because it's now enabled.")
	assertEquals(CountCommandLineNamelessArgumentsPresent, 1, "We should have one nameless argument.")
	assert(ParseCommandLineArguments("-v valid-value nameless-argument-value"), "ParseCommandLineArguments() should accept nameless arguments because it's now enabled.")
	assertEquals(CountCommandLineNamelessArgumentsPresent, 1, "We should have one nameless argument.")
	
	// Check quotes And backslash
	assert(ParseCommandLineArguments("-v "+Chr(34)+"value in quotes"+Chr(34)), "ParseCommandLineArguments() should be able To handle values with spaces enclosed in quotes.")
	assertEquals(getCommandLineArgumentValue("-v"), "value in quotes") // Note: No quotes around the value!
	assert(ParseCommandLineArguments("-v value-with\"+Chr(34)+"quote-in-it"), "ParseCommandLineArguments() should be able To handle values with escaped quotes.")
	assertEquals(getCommandLineArgumentValue("-v"), "value-with"+Chr(34)+"quote-in-it") // Note: one quote in the middle, but no \
	assert(ParseCommandLineArguments("-v value\\with\\backslashes"), "ParseCommandLineArguments() should be able To handle values with escaped backslashes.")
	assertEquals(getCommandLineArgumentValue("-v"), "value\with\backslashes")
EndFunction

Function test_getCommandLineArgumentValue()
	// getCommandLineArgumentValue() is actually already tested by test_ParseCommandLineArguments(), but here are some extensive assertions.
	
	// First define that our program has been called with the argument "-v value".
	ParseCommandLineArguments("-v value")
	
	// Test that we get the same value with both Short And long argument name
	assertEquals(getCommandLineArgumentValue("--valid-argument"), "value", "getCommandLineArgumentValue() should Return 'value' For --valid-argument.")
	assertEquals(getCommandLineArgumentValue("-v"), "value", "getCommandLineArgumentValue() should Return 'value' For -v.")
	
	// Test the we get the Default value If an argument is Not defined
	assertEquals(getCommandLineArgumentValue("-b", "Default"), "Default", "getCommandLineArgumentValue() should Return 'Default' because -b is Not present.")
	assertEquals(getCommandLineArgumentValue("--undefined-argument", "Default"), "Default", "getCommandLineArgumentValue() should Return 'Default' because --undefined-argument is Not even defined.")
	
EndFunction

Function test_isCommandLineArgumentPresent()
	// First define that our program has been called with the argument "-v value".
	ParseCommandLineArguments("-v value")
	
	// These arguments should be present:
	assert(isCommandLineArgumentPresent("-v"), "isCommandLineArgumentPresent() should notice that -v is present.")
	assert(isCommandLineArgumentPresent("--valid-argument"), "isCommandLineArgumentPresent() should notice that --valid-argument is present.")
	
	// These arguments should Not be present:
	assertNot(isCommandLineArgumentPresent("--non-existing-argument"), "isCommandLineArgumentPresent() should notice that --non-existing-argument is not present.")
	assertNot(isCommandLineArgumentPresent("-a"), "isCommandLineArgumentPresent() should notice that -a is not present.")
	assertNot(isCommandLineArgumentPresent("-b"), "isCommandLineArgumentPresent() should notice that -b is not present.")
EndFunction


//
// TODO: Add tests for the rest of the functions in CommandLineArguments.cb, both public and internal ones.
//




//
// GetWord2() and CountWords2()
// These are copied here because they are not included in CommandLineArguments.cb but CommandLineArguments needs these during testing.
//

// Copied 2021-02-12 from http://www.cbrepository.com/codes/code/11/
// Created 2011-04-09 by KilledWhale
// Modifications:
//  - added $ to the GetWord2() function name. No other modifications
//  - Made the function FVD compatible
Function GetWord2$(a As String, b As Integer, c As String)
   Dim l, i, q // Force Variable Declaration
   
   l = Len(c) // Otetaan pituus muuttujaan optimoinniksi
	For i As Integer = 2 To b // Käydään läpi kaikki ei-halutut sanat
	  q = InStr(a, c) // Katsotaan löytyykö erotinta
		If q Then // Löytyi
			a = Mid(a, q + l) // Otetaan alkuosa pois erottimeen asti
	  EndIf
	Next i

   q = InStr(a, c) // Katsotaan vielä löytyykö erotinta
	If q Then // Jos löytyi
		Return Mid(a, 1, q - 1) // Palautetaan tekstiä seuraavaan erottimeen asti
	Else // Ei löytynyt
		Return Mid(a, 1) // Palautetaan loppuosa
	EndIf
EndFunction

// Copied 2021-02-12 from http://www.cbrepository.com/codes/code/11/
// Created 2011-04-09 by KilledWhale
// Modifications: Made the function FVD compatible
Function CountWords2(a As String, c As String)
   Dim n, aa // Force Variable Declaration
   
   Repeat
	  n + 1 // Kasvatetaan arvoa, että montako ON löydetty
	  aa = InStr(a, c, aa + 1) // Katsotaan löytyykö erotinta
	  If Not aa Then // Jos ei löydy
		 Exit // Poistutaan
	  EndIf
   Forever
   Return n // Palautetaan esiintymien määrä
EndFunction
